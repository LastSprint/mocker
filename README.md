# Mocker

Это приложение, которое позволяет имитировать работу реального backend'а.

Само по себе приложения представляет из себя обычный ротуер HTTP-запросов. 
Приложение принимает запрос из сети, парсит URL и HTTP-method. Затем проходится по известным мокам. Берет мок с подходящим URL и HTTP-method'ом, читает код ответа и тело ответа, а затем возвращает ответ клиенту.

В случае, если существует несколько моков с одинаковыми URL и Method, то приложение объединяет их в группу а затем закольцовано итерирует по ним.

После того, как были внесены изменения в моки необходимо, чтобы сервер обновил у себя данные.

Сделать это можно так: `curl 127.0.0.1:port/update_models`

## Моки

Моковые файлы представляют из себя `Json` формата:
```
 {
    "url": string,
    "method": string,
    "statusCode": int,
    "response": object,
    "request": object
 }
```

Буквально здесь записано следующее:
На запрос с `URL = url` и `Method = method` вернуть ответ `response` с кодом `statusCode`

### URL

Может быть следующих видов:

1. `path/to/endpoint` - обычный url адрес. Во время получения запроса сервис будет сравнивать строки посимвольно.
2. `path/to/endpoint/{number}` - url с path-паттерном. Мок с таким URL будет реагировать на любой запрос который удовлетворяет этому шаблону.
3. `path/to/endpoint/data?param={value}` - url c parameter-паттерном. Мок с таким url сработает на запрос, содержащий заданные параметры. При этом, если одного из параметров не будет в запросе, то он не сматчится с шаблоном.

### Method

Пишите названия HTTP методов в UpperCase. 
**НЕ** `get` **А**  `GET` 

### Status Code

Любое целое число. Желательно из известных [HTTP-кодов](https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP)

### Response

Это поле содержит `Json`, который вернется в ответ на запрос. 

### Request

Это поле содержит данные для проверки. 

Когда приходит запрос сервис пытается извлечь из него тело. 

Если ему это удается, то он выполняет поиск нужной группы моков (по URL и http-методу).

Затем сервис сравнивает `request.body` и `mock.request`. Если он находит подходящий мок, то возращает его. Иначе следует стандартной стратегии.

То есть это поле нужно для того, чтобы связать запрос с ответом в том числе с помощью матчинга тела запроса. 

Таким образом пользователь может задать два разных мока на два разных тела запроса и всегда получит конкретный мок. 

<details>
 
<summary>Пример</summary>

mock1.json:

```json
{
 "url": "/exmp",
 "method": "POST",
 "statusCode": 200,
 "request": {
  "login": "valid",
  "password": "valid"
 },
 "response": {
  "accessToken": "token==",
  "refreshToken": "refresh"
 }
}
```

mock2.json:

```json
{
 "url": "/exmp",
 "method": "POST",
 "statusCode": 400,
 "request": {
  "login": "valid",
  "password": "invalid"
 },
 "response": {
  "code": 1,
  "message": "Bad Credentials"
 }
}
```

В случае если в теле запроса `password == valid`, то вернется 200й код.
А если `password == invalid`, то вернется 400й код. 
В противном случае ответы будут возвращаться итеративно. 

</details>

## Конфигурация

Приложение имеет конфиг в `Json` следующего формата:
```
{
    "mocksRootDir": string,
    "port": int,
    "logPath": string
}
```

### Mocks Root Dir

Это путь до папки, которая является корневой для файлов с моками. 

### Port

TCP-порт, который будет слушать приложение

### Log Path

Путь до файла с логами. Туда приложение будет писать логи работы.

## Docker

Чтобы запустить сервис с web-ui через докер нужно выполнить:

```
cd docker
docker-compose -p mocker --no-cache up
```
## Проксирование
Mocker поддерживает функцию проксирования. 
Клиент делает запрос в Mocker.
Mocker перенаправляет запрос на реальный сервер
Если вернулся ответ с 200-м кодом, то Mocker сохраняет полученный ответ как моковый файл. 
Mocker возращает клиенту ответ от сервера

Эта функция может быть очень полезна когда вам нужно поддерживать актуальную базу моков.
Для того, чтобы использовать эту функцию неоьбходимо установить 3 кастомных хедера в тот запрос, для которого нужно использовать эту функциональность.

```
X-Mocker-Redirect-Is-On: "true",
X-Mocker-Redirect-Host: "hostaname.ex:1234", // адрес хоста (опционально с портом) на который нужно перенаправить запрос
X-Mocker-Redirect-Scheme: "http"
```
